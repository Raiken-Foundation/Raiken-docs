---
title: Examples
description: Sample prompts, generated tests, and workflows.
---

## Prompts that work well

Raiken works best with specific, action-oriented prompts. Here are patterns that produce good results:

### Component-specific tests

```text
Generate tests for @src/components/Counter.tsx
```

```text
Test the login form at http://localhost:3000/login
```

```text
Create E2E tests for the TodoList component
```

### Feature-based tests

```text
Test the user registration flow
```

```text
Generate tests for the checkout process
```

```text
Test adding items to cart and completing purchase
```

### With URL context

```text
Test the dashboard at http://localhost:3000/dashboard
```

```text
Generate tests for http://localhost:3000/settings
```

### Refinement prompts

After an initial generation, you can refine:

```text
Add error case tests
```

```text
Include accessibility assertions
```

```text
Add tests for edge cases
```

## Example generated test

Here's a real test generated by Raiken for a Counter component:

```ts title="tests/counter.spec.ts"
import { test, expect } from '@playwright/test';

test.describe('Counter Component', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should display initial counter value of 0', async ({ page }) => {
    await expect(page.getByTestId('counter-value')).toHaveText('0');
  });

  test('should increment counter when clicking increment button', async ({ page }) => {
    const counterValue = page.getByTestId('counter-value');
    const incrementButton = page.getByRole('button', { name: 'Increment' });
    
    await incrementButton.click();
    
    await expect(counterValue).toHaveText('1');
  });

  test('should decrement counter when clicking decrement button', async ({ page }) => {
    const counterValue = page.getByTestId('counter-value');
    const decrementButton = page.getByRole('button', { name: 'Decrement' });
    
    // First increment to have something to decrement
    await page.getByRole('button', { name: 'Increment' }).click();
    await expect(counterValue).toHaveText('1');
    
    await decrementButton.click();
    
    await expect(counterValue).toHaveText('0');
  });

  test('should reset counter to 0 when clicking reset button', async ({ page }) => {
    const counterValue = page.getByTestId('counter-value');
    
    // Increment several times
    await page.getByRole('button', { name: 'Increment' }).click();
    await page.getByRole('button', { name: 'Increment' }).click();
    await expect(counterValue).toHaveText('2');
    
    await page.getByRole('button', { name: 'Reset' }).click();
    
    await expect(counterValue).toHaveText('0');
  });
});
```

## Tips for better results

1. **Be specific about the user flow** — "Test login" is vague; "Test that a user can log in with valid credentials and see the dashboard" is better.

2. **Include visible UI text** — Reference button labels, headings, or placeholder text that Raiken can match in the DOM.

3. **Mention the URL if relevant** — This helps Raiken capture the right page context.

4. **Iterate** — Start with a basic prompt, review the output, then refine with follow-up prompts.

## What to avoid

- **Vague prompts** — "Test everything" won't produce useful results.
- **Implementation details** — Describe what the user does, not how the code works.
- **Multiple unrelated flows** — Break complex scenarios into separate prompts.
